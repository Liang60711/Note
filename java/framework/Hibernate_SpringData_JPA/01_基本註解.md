## interface 關係
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20211210003119/crudvsjpadrawio.png" width=30%>

<br/>

<br/>

## 實體類規則

1. 屬性是 `private` 
2. getter 和 setter 為 `public`
3. 需有一個屬性為唯一值，一般使用 id 值
4. 實體類屬性建議不使用基本數據類型(`int`)，而使用數據類型對應的封裝類(`Integer`)。

    ```java
    // 舉例: 表示學生的分數

    // 使用 Integer
    Integer score = 0;      // 學生考0分
    Integer score = null;   // 學生沒參加考試

    // 使用 int
    int score = 0           // 不能區分學生是 考0分 還是 沒參加考試
    int score = null;       // int 不能為 null，會報錯
    ```

<br/>

<br/>

## 主鍵生成策略

|strategy|說明|
|--|--|
|increment|PK自動加1|
|identity|PK自動加1，但需要SQL是有支持的，如 `ORACLE`  就不支持|
|sequence|需要支持序列的SQL，如 `ORACLE` 才有支持|
|*native|自動系統選擇，不用擔心要選 identity 還是 sequence |
|*uuid|會自動生成 uuid，但要注意Entity中的 id 屬性類型須改為 `String`|

<br/>

<br/>

## @Entity 屬性
name 屬性用來指定`資料表名稱`，若沒有指定 name 屬性，預設會是小寫的 class name，即 `student`
```java
@Entity(name = "student")
public class Student {

    //
}
```

<br/>

<br/>

## @SequenceGenerator 屬性
> https://matthung0807.blogspot.com/2021/06/spring-data-jpa-custom-sequence-generator-oracle.html
1. 使用自訂序號產生器產生序號必須為有支援序號的SQL，例如 `oracle`, `postgreSQL`, `SQLServer`


2. 若使用 `@GeneratedValue(strategy="SEQUENCE")`，則必須要額外加上 `@SequenceGenerator` 註解。


3. 使用資料庫的序列 sequenceName = `student_sequence`。

4. 序列產生器名稱為 name = `student_sequence`。

5. `allocationSize` 表示每次主键值增加的大小，例如設置1，則表示每次插入新紀錄後自動加1 (1,2,3...)，預設為50 (50, 100, 150...)

    ```java
    @Entity(name = "student")
    public class Student {

        @Id
        @SequenceGenerator(
            name = "student_sequence",          
            sequenceName = "student_sequence",
            allocationSize = 1
        )
        @GeneratedValue(
            strategy = SEQUENCE,
            generator = "student_sequence"
        )
        private Long id;
    }
    ```


<br/>

<br/>

## @Colomn
1. 映射資料表中的欄位

2. `columnDefinition`: 一般用於透過 Entity 生成資料表時定義使用，如果資料表已經建好，該屬性就没有必要使用。

3. unique, nullable

    ```java
    @Entity
    public class Student {
        
        @Column(
            name = "name",
            nullable = false,
            columnDefinition = "varchar(128) not null"
        )
        private String fname;

        @Column(
            name = "description",
            columnDefinition = "TEXT"
        )
        private String description;

        @Column(
            name = "email",
            unique = true
        )
        private String email;
    }

    ```

<br/>

<br/>

## @Embedded / @Embeddable
1. 主要目的是將一張欄位過多的資料表拆分成 n 個類去映射

    |id|name|age|c_id|c_name|c_age|
    |--|--|--|--|--|--|

    <br/>

    <br/>

2. @Embedded放在類的屬性，@Embeddable放在要被嵌入的類。

3. 可以去 override 被嵌入類的欄位名稱

<br/>

<br/>

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
public class Student {
    private Long id;
    private String name;
    private Integer age;

    @Embedded   // 將拆分的類嵌入
    private CStudent cStudent;
}
```
```java
@Embeddable // 將被嵌入的類
@AttributeOverrides({// 複寫此類屬性名稱，映射至資料庫欄位名稱
    @AttributeOverride(
        name = "id",
        column = @Column(name = "c_id")
    ),
    @AttributeOverride(
        name = "name",
        column = @Column(name = "c_name")
    ),
    @AttributeOverride(
        name = "age",
        column = @Column(name = "c_age")
    )
})
public class CStudent {
    private Long id;
    private String name;
    private Integer age;
}
```

<br/>

<br/>

## @Query
此註解可以使用
1. JPQL
2. 原生 SQL

<br/>

<br/>

`JPQL寫法`
```java
@Query("select s from Student s where s.emailId = ?1")
Student getStudentByEmailAddress(String emailId);
```
`Native SQL`，加上 `nativeQuery` 屬性
```java
@Query(
    "select * from student s where s.emailId = ?1",
    nativeQuery = true 
)
Student getStudentByEmailAddressNative(String emailId);
```

<br/>

<br/>

@Query 中的佔位浮有2種 (JPQL 和 Native SQL 都可以用)
```java
// 1. 使用 ?1 ?2 ?3 ...
// 好處是不用指定參數順序
@Query("select s from Student s where s.emailId = ?1")
Student getStudentByEmailAddress(String emailId);
```

```java
// 2. 使用 : 冒號作為佔位符
// 需要使用 @Param 註解指定參數順序
@Query("select s from Student s where s.emailId = :emailId and s.name = :name ")
Student getStudentByEmailAddress(
    @Param("emailId") String emailId,
    @Param("name") String name
);
```

<br>

<br/>

## @Modifying
使用在 `修改update` 和 `刪除delete`，不能用在`新增create。`


<br/>

<br/>

## 自動加上 created_date 和 updated_date
1. 先在專案進入點加上 `@EnableJpaAuditing`

    ```java
    @SpringBootApplication
    @EnableJpaAuditing
    public class JpaApplication {

        public static void main(String[] args) {
            SpringApplication.run(JpaApplication.class, args);
        }

    }
    ```

2. 在 Entity class 上加上 `@EntityListeners`，監聽實體

    ```java
    @Entity
    @Table(name = "student")
    @EntityListeners(AuditingEntityListener.class)
    public class Student {

    }
    ```

3. 在實體中加上對應的屬性
    
    ```java
    @CreatedDate(updatable = false)     // 建立後不能做修改
    @Temporal(TemporalType.TIMESTAMP)   // 預設
    private Date createdDate;

    @LastModifiedDate
    @Temporal(TemporalType.TIMESTAMP)
    private Date updatedTime;
    ```

4. 資料表的欄位必須要有變更，否則 update_time 不會有更動。
5. `@Temporal` 屬性

    * @Temporal(TempralType.DATE)   : 精確到年月日
    * @Temporal(TempralType.TIME)   : 精確到時分秒
    * @Temporal(TempralType.TIMESTAMP)  : (預設，精確到毫秒)