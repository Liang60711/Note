# InnoDB的數據頁

## 概述

1. 為 InnoDB 存儲引擎中的基本單位，用來存放數據，每頁的預設大小為 16 KB；
    
    ```sql
    -- 查看頁容量大小
    show variables like '%innodb_page_size%';
    ```

    補充: 在 ORACLE 中是使用 `Block` 來代表 `Page`。SQL Server 中頁的大小為 8KB。


2. 硬碟將數據載入到記憶體中，或是將記憶體中的數據回寫到硬碟，都是以頁為基本單位，即`I/O的操作最小單位是頁`。

    * 補充: 就算是讀1筆資料，也還是會載入1頁到記憶體中。

3. 頁內部儲存的數據是以`單向Linked List`，而單向鏈表的缺點就是查詢慢，需遍歷查找，時間複雜度 `O(n)`；所以需要`頁目錄`加快查找速度，實現二分法查找，時間複雜度為提升為`O(log n)`。

    <img src='../../_image/Snipaste_2023-11-28_01-53-22.png'>


<br/>

<br/>

## 頁的上層結構

`區 Extent`:   

* 比頁大一級的儲存單位，為`連續的記憶體區塊`，在 InnoDB中，一個 Extent 有 `64個連續的頁`，因此一個 Extent 大小為 16KB * 64 = `1MB`

* 可分為4類

    1. 空閒區(FREE): 尚未使用到這個區中的任何頁。

    2. 有剩餘空間的碎片區(FREE_FRAG): 表示碎片區中還有可用的頁面。

    3. 沒有剩餘空間的碎片區(FULL_FRAG): 表示碎片區中的所有頁面都被使用，沒有空閒頁。

    4. 屬於某個段的區(FSEG): 每一個索引都可以分為葉節點段、非葉節點段。

    * 處於FREE、FREE_FRAG 以及 FULL_FRAG 這三種狀態的區都是獨立的，直屬`Tablespace表空間`。而 FSEG 狀態的區是附屬於某段的。


`段 Segment`:  

* 由一個或多個 Extext 組成，不一定是連續的記憶體區塊，`Segment是資料庫中的分配單位，不同類型的資料庫物件以不同的 Segment形式儲存`。

* 舉例: 創建資料表、索引時，Table、Index 這樣的資料庫物件都會在底層創建一個獨立的 Segment。

`表空間 TableSpace`

* 表空間可以看做是InnoDB儲存引擎邏輯結構的最高層，所有的資料都存放在表空間中。


<br/>

<br/>

<img src='../../_image/Snipaste_2023-11-30_16-51-26.png'>

<img src='../../_image/Snipaste_2023-12-01_04-21-47.png'>

<br/>

<br/>

### 為什麼要有Extent(區) ?

由於`範圍查詢`的方式是，定位到最左邊和最右邊的紀錄，然後沿著雙向鏈表向右掃描就可以了，所以如果是沒有使用 Extent，鏈表的兩個頁之間的`物理位置會非常遠`，這就是`隨機I/O`，隨機I/O是非常慢的，故需要 Extent 盡量讓頁之間物理位置相鄰，範圍查詢時才可以使用`順序I/O`。

`隨機I/O（Random I/O）`是指在存儲設備上讀取或寫入數據時，數據的存儲位置是不連續的，並且沒有順序的模式。

`順序I/O（Sequential I/O）`則是按照順序讀取或寫入數據，存儲位置是連續的。

<br/>

<br/>


### 為什麼要有Segment(段) ?

主要也是針對`範圍查詢`，如果非葉節點、葉節點放在同一個連續記憶體區塊中，會降低掃描效率，故InnoDB設計，葉節點一個 Segment，非葉節點一個 Segment，也就是說，一個索引 B+ Tree 會生成 2 個 Segment，`一個葉節點段，一個非葉節點段`。


InnoDB引擎中，Segment 的管理皆是由引擎自身完成的，沒有必要進行手動控制。

<br/>

<br/>

### 為什麼要有 Fragment 碎片區 ?

`原因`:  
在 InnoDB，創建一張表時，會有一個叢集索引，一個索引會生成2個Segment(葉節點Segment、非葉節點Segment)，而 Segment 是以 Extent 為單位申請儲存空間的，一個Extent預設是 16KB * 64 = `1024KB`，等於是一張表就要佔2MB，即使是紀錄很少，這樣其實很浪費儲存空間。

`解決方式`:  
為了`數據量較小`的表浪費太多儲存空間，InnoDB 使用了`碎片區(Fragment)` 的概念，此碎片區直屬於`表空間(TableSpace)`，在一個碎片區中，不是所有的頁都是為了儲存同一個 Segment 的數據而存在的，而是碎片區中的頁可以用於不同目的。

`申請儲存空間的流程`:
1. 在建立表後，會向表空間中的`碎片區`申請一個頁。
2. 當資料容量超過到`32個頁`，就會申請一個完整的 Extent 作為儲存空間。

<hr/>

<br/>

<br/>

### 頁的內部結構

依照類型區分，頁常見的有以下幾種類型

* 數據頁 (B+ Tree節點)
* 系統頁
* Undo頁
* 事務數據頁

`16 KB` 大小的空間被劃分成七個部分

|名稱|占用大小|說明|
|--|--|--|
|File Header|38 Byte|描述頁的資訊|
|Page Header|56 Byte|頁的狀態資訊|
|Infimum+Supremum|26 Byte|最小和最大紀錄，這是兩個虛擬的行紀錄|
|User Records|不確定|用戶紀錄，真正用來儲存紀錄的空間|
|Free Space|不確定|空閒紀錄，頁中還沒有被使用的空間|
|Page Directory|不確定|`頁目錄`，儲存用戶紀錄的相對位置|
|File Trailer|8 Byte|文件尾部，驗證頁是否完整|

<img width='60%' src='../../_image/Snipaste_2023-12-01_04-25-39.png'>

<br/>

### Header 資訊中有數十項，這邊只舉例幾項

`File Header` :
* 頁和頁之間的雙向鏈表地址，`FIL_PAGE_PREV` 和 `FIL_PAGE_NEXT`。

`Page Header`:
* 紀錄`頁目錄`中Slot數量

* 未使用的空間的最小地址


---

### 為什麼需要頁目錄?

頁中的每筆紀錄是由單向鏈表組成的，優點是插入、刪除快速，但查詢的效率就不高，最差情況時間複雜度為 `O(N)`，即遍歷完整個鏈表。

為了加速查詢，專門記錄一個目錄，通過`二分查找法 Binary Search`，將時間複雜度穩定為 `O(log n)`。

實作方式為:

1. 例如本頁中有1000筆紀錄，分為幾個組，每組取最小和最大值。

2. 頁目錄會儲存`每一組最後一筆紀錄的地址偏移量`，這些地址偏移量會依照先後順序儲存起來。

3. 每組的地址偏移量也稱為 `Slot` (槽)，每個 Slot 相當於指針指向了不同組的最後一筆(最大)紀錄。

4. 當查找時，會先在頁目錄中比大小，看是哪一組，就直接指到那一組再去查找。

    <img src='../../_image/Snipaste_2023-12-01_03-03-33.png'>

<br/>

<br/>

<br/>

<br/>

## 數據行格式

這邊指的是每筆存在數據頁中的單筆數據。

下圖是以 `COMPACT行格式` 舉例結構

<img src='../../_image/Snipaste_2023-12-01_01-35-35.png'>

<img src='../../_image/Snipaste_2023-12-01_01-37-30.png'>

<br/>

next_record: 非常重要的屬性，是紀錄紀錄下一筆紀錄`地址偏移量`，紀錄偏移量比較省空間，而非絕對位址。

最終依照主鍵(索引)，串成鏈表，其中最小/最大值會被另外紀錄在 Page 的 `Infimum  + Supremum` 中。

<img src='../../_image/Snipaste_2023-12-01_01-55-16.png'>

<br/>

由於數據行的單向鏈表結構，在刪除時很方便，會將 `next_record` 指向下一筆紀錄(修改偏移量)，並將刪除的數據行 `delete_mask` 屬性設為 `1`。

這樣並沒有真正將數據刪除，只是排除在鏈表中，因為刪除要移動數據行成本高，若有新的數據行要插入，則會覆蓋掉 delete_mask 被標示為刪除的數據行。

<br/>

<br/>

## Reference

> https://wenb1.github.io/2020/07/25/mysql-innodb-page/