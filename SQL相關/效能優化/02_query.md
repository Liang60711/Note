## 下查詢
1. 避免使用 * 的原因:

    * 若不寫欄位名稱，直接使用 `*`，DB會去查詢表中的數據字典，將 `*` 動態轉為欄位名稱，多一層轉換。

    <br/>

2. 當需要刪除整張表的數據時，使用 TRUNCATE 代替 DELETE。

    * TRUNCATE: 只保留資料表結構、約束、索引，效率較DELETE高(只會鎖表)；該表的 PK 也會一併重置。

    * DELETE: DELETE屬於DML命令，會逐行刪除資料列(鎖每一筆資料)，並在 Transaction 中記錄每筆刪除的資料，耗費資源龐大；該表的 PK 並不會重置，仍會從之前最後一個編號繼續。

    * DROP: 刪除所有資料表結構、約束、索引、資料、權限規則。

3. 計算紀錄總數

    * MyISAM引擎效能 : COUNT(*) = COUNT(1) = COUNT(col)

        1. 三者時間複雜度都是`O(1)`，原因是MyISAM的每張表都有一個meta信息儲存了row_count值，一致性由表級鎖來實作。


    * InnoDB引擎效能 : COUNT(*) = COUNT(1) > COUNT(col)
        
        1. 時間複雜度都是`O(n)`，InnoDB 因為支持事務，採用行級鎖和MVCC機制，所以無法像MyISAM，只維護一個row_count變數，因此需要採用掃描全表的方式來計算行數。

        2. 如果只要查行數，不查具體資料，使用 COUNT(*) 時，系統會自動使用二級索引(非叢級索引)，而非叢級索引，原因是叢級索引包含的資訊太多，故會選用占用空間較小的二級索引來統計；如果有多個二級索引，會使用 key_len 小的二級索引進行統計；當沒有二級索引時，才會採用PK索引來統計。

        3. 呈第2點，使用 COUNT(*)，系統會自動找最優的二級索引去統計行數，如果使用 COUNT(col) 指定欄位，就沒有辦法使用系統的自動優化了。

4. 某些使用 SubQuery 情況下，用 EXISTS 替代 IN

    * 先講結論:

        * 兩張表大小差不多，用 EXISTS 和 IN 差異不大。
        * 子查詢是小表，可用 IN。
        * 子查詢是大表，需用 EXISTS。
        * 以小表驅動大表，效率高 (遍歷小表的成本較小)。

        * 使用 IN，主查詢和子查詢都可以使用索引
        * 使用 EXISTS，查詢僅子查詢可以使用到索引，外表會全表掃描。

        <br/>

    * 使用EXISTS : `select * from A where exists (select x from B where B.id = A.id)`

        * SQL執行順序，會從主查詢來遍歷，會先遍歷A表的所有資料，再判斷與B表是否符合，只要找到一筆符合條件的列，就會停止搜尋。
        
        * 假設，A表有10筆資料，B表有1000筆資料，使用 EXISTS，只需判斷10次；若A表有10筆資料，B表有10000筆資料，也是只需判斷10次，因為EXISTS是用一整個集合來做比較，在效能上來說會比較快。

        * 呈上，當A表、B表資料量差異越大，使用 EXISTS 就越有效率。

        * 子查詢的 `x欄位` 根本就不重要，只是為了判斷 true/false，故子查詢的重點是在 where。

        <br/>


    * 使用IN : `select * from A where id in (select id from B)`

        * SQL執行順序，會從子查詢來遍歷，會先遍歷B表的所有 id 欄位並暫存至`加了索引的臨時表中`。然後檢查A表的 id 是否與臨時表條件相符合，如果相等則將A表的記錄加入結果集中，直到遍歷完A表的所有記錄。

        * 當B表數據較大時不適合使用 IN，因為會把B表數據全部遍歷一次(沒有索引情況下，走不走索引取決於SQL的執行計畫)。

        * 最差情況，A表、B表都會完整的遍歷，所以效能會較差。

        <br/>

5. 用 `>=` 替代 `>`

6. 數字比較，使用 BETWEEN 取代 WHERE IN

    * `select * from user where id in (1,2,3)` 避免使用

    * `select * from user where id between 1 and 3`

7. 不考慮重複狀態下，使用 UNION ALL 比 UNION 好

    * UNION 是將兩結果合併，並去除重複，但會經過遍歷、比對，很耗效能，但有去重複需求還是得用。

    * UNION ALL 是將兩結果合併，不去除重複。

<br/>

<br/>


## Reference 

> IN 和 EXISTS 比較 https://segmentfault.com/a/1190000023825926