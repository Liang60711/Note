## 連接池 connection pool

> http://peggg327.blogspot.com/2014/11/connection-pool.html

1. 為何要有連接池?

    * 一般沒有使用Connection Pool的程式，當需要存取資料庫時，便要建立一個直接與 DB 相連的連線(Physical Connection)。
    * 資料庫連線的建立成本是昂貴的，當有許多 Thread 都需要建立 connection 時，其資源的耗費是龐大的，一個成本昂貴的 connection 在程式使用完後，馬上就被Close掉，在使用上並沒有達到效益極大化。
    * 程式中請求建立的總連線數可能超過 DB 允許的連線數而發生 Exception。
    * 連接池的存在，可以降低對資料庫建立連線/關閉的次數，因為 pool 中的連線是可重複使用的，且每次的連線都是從 pool 中取得。

2. 連線池的流程

    * AP中加入Connection Pool後。程式啟動時，Connection Pool 會先跟 DB 建立好連線(連線數可設定)，並且keep住這些連線；當程式需要使用 Connection 時，pool便會將手上可用的 Connection 借給程式，程式使用完後再歸還給 Pool 即可。

3. 連線池的好處

    * 減少連線、關閉資源。
    * 可以設定最大連線數，避免超過 DB 所能負擔的連線數。

4. 常用的 JDBC connection pooling: 
    * Apache Commons 
    * HikariCP 
    * CPC3PO
    * Druid


5. 在 postgreSQL 中，查看最大連線數量

    ```sql
    SHOW max_connections;
    ```
6. 在 postgreSQL 中，查看執行個體中，每個資料庫的連線數量

    ```sql
    SELECT datname, numbackends FROM pg_stat_database;
    ```

7. 與 JDBC 的關係: DataSource提供了數據庫連接，而JdbcTemplate使用該連接來執行SQL操作，因此 `JdbcTemplate 依賴 HikariCP`。

<br/>

<br/>


## 鎖 Lock 

> 鎖的解釋 https://hackmd.io/@gysdnow/H1RJgsk5L

> update lock 目的 https://ithelp.ithome.com.tw/articles/10254610#update-lock-%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E7%BE%A9

> 意圖鎖的作用 https://www.zhihu.com/question/51513268

> 意圖鎖的兼容性 https://juejin.cn/post/7167957408583516173

1. 鎖解決的問題: 用於防止並發操作引起的資源衝突。
2. 鎖的粒度(範圍)越小，記憶體成本越大；
3. 鎖的種類
    * Shared Locks (S)，又稱`讀鎖`
        * 主要用於讀取操作，在讀取到的資料上設置共享鎖。其他會話可以讀取這些資料，也可以繼續給資料繼續加共享鎖，但是在當前事務提交(commit)之前其他會話不能修改加了共享鎖的這筆資料。
        * 如果這些資料其中一筆被尚未提交的另一個事務更改，則當前查詢將等待直到該事務結束，然後使用最新值。
        * Mysql 語法為 `SELECT ... LOCK IN SHARE MODE`

    * Exclusive Locks (X)，又稱`寫鎖`
        * 禁止其他事務在這些加了鎖的資料上進行 `UPDATE`、也`禁止續加讀鎖、寫鎖`。
        * Mysql 語法為 `SELECT ... FOR UPDATE`

    * Update Locks (U)
        * 目的是避免 Dead lock，是一個過渡的狀態，讓其他的Session在 Shared Lock 狀態等待。
        * 更新資料時，步驟如下。

            `Shared Lock => Update Lock => Exclusive Lock`

            Shared Lock : 查詢更新的資料。

            Update Lock : 更新前把資料改成 Update Lock。

            Exclusive Lock : 確定要更新當下改成 Exclusive Lock。
        
        * 關鍵在於`Shared Lcok不互斥，Update Lock互斥`: 先拿到 Update Lock 的 Session 可以避免其他 Session 拿 Update Lock，只能留在 Shared Lock 等待。

    * Intent Locks (I)，`意圖鎖`
        * 意圖鎖解決的痛點 : 
        
            `加表鎖 = 遍歷判斷每行資料並加上行鎖`，過程會檢查每行是否已經有`行鎖`，沒有行鎖才會加上 (如果不判斷直接每行都鎖的話，會和原有的行鎖造成死鎖)，但如果數據庫中的數據有海量時，遍歷會造成性能下降。

            因此增加了意圖鎖的概念，在加`行鎖`之前先加表級的`意圖鎖`，其它事務能以較小的代價得知資料表有行正在被鎖定。
            
        * 是一種`表級別`的鎖，所以意圖鎖與`行級別`的鎖並沒有競爭關係。
        * 任意 IS/IX 鎖之間都是兼容的，因為它們只是表示想要對表加鎖，而不是真正加鎖。
        * 意圖鎖是由SQL引擎自己維護的，用戶無法手動操作意向鎖，所以還是依照原本的加鎖語法。

            ```sql
            -- 讀鎖
            SELECT ... LOCK IN SHARE MODE

            -- 寫鎖
            SELECT ... FOR UPDATE
            ```
        * `意圖鎖`的存在代表`此表中有行鎖的存在或即將有行鎖存在`。

    * Schema Locks (Sch)
    * Bulk Update Locks (BU)
    * Key-range


4. 讀鎖 v.s. 寫鎖: 
    * 同一筆資料上，只允許一個寫鎖，但可以有多個讀鎖。
    * 這兩種鎖都不會阻塞普通 SELECT語句讀取這些行，`快照讀`將忽略行記錄上設置的任何鎖。

<br/>

4. `表鎖`的衝突表，表格中的4種鎖都以表鎖來討論(不包含行鎖)。
    
    ||X|IX|S|IS|
    |:--:|:--:|:--:|:--:|:--:|
    |X|`衝突`|`衝突`|`衝突`|`衝突`|
    |IX|`衝突`|相容|`衝突`|相容|
    |S|`衝突`|`衝突`|相容|相容|
    |IS|`衝突`|相容|相容|相容|

    <br/>

    補充 

    1. `寫鎖(X)`如果是表鎖，表示獨佔整個表，因此與任何鎖都衝突，但如果是行鎖，就不會和表級別的IX鎖衝突，否則資料表無法同時update不同行的資料，資料表要能夠同時可以修改不同行的資料(上面的表格中，X指的是表級X鎖)。

    2. IX，IS是表級鎖，不會和行級的X，S鎖發生衝突。只會和表級的X，S發生衝突。
    3. IX 和 IX 只要表示修改不同行，就不會衝突，IS 與 IX 同理，不同行就不衝突。
    4. S 和 IS 表示共享鎖，彼此皆不會衝突。
    5. S 和 IX 衝突原因是，此表已經有S鎖，就不能再加上行級 X 鎖。

    <br/>

    <br/>




`樂觀鎖 Optimistic Lock`
1. 常應用在`讀多寫少`的情境，並不會在資料庫中真的使用加鎖語法，

2. 實作方式是使用`version 欄位`，version 欄位表示數據被修改的次數，當數據被修改時，version 值會加1。

3. 更新資料的步驟是

    1. 找出要檢查的資料

        ```sql
        -- version 抓取商品數量、version次數
        SELECT num,version FROM `MyDB`.`items` where id = 1;
        ```
    2. 更新時需一併帶上將version條件帶上

        ```sql
        UPDATE `MyDB`.`items` 
        SET 
            num = num -1 ,          -- 商品數量減1
            version = version + 1   -- 修改次數加1
        WHERE id = 1 and version = 0; -- 條件需要帶上步驟1查詢到的version值
        ```


    3. 若步驟2中的 WHERE 條件都符合，才會進行更新，這樣做的好處是: `能避免因使用悲觀鎖而導致吞吐量下降`(因為有鎖，後面的指令都會等待)的問題。



4. 比較適合讀取操作比較頻繁的場景，如果出現大量的寫入操作，數據發生衝突的可能性就會增大，爲了保證數據的一致性，應用層需要不斷的重新獲取數據，這樣會增加大量的查詢操作，降低了系統的吞吐量。

5. 優點 : 因為沒有加鎖，只有在更新資料時才會做驗證，不會有因為使用鎖導致吞吐量下降的問題。

6. 缺點 : 樂觀鎖是人為實現的，所以如果換一個業務場景可能會不適用，甚至可能因為其他的 SQL command 導致錯誤。


`悲觀鎖 Pessimistic Lock`
1. 常應用在`寫多讀少`的情境，會使用資料庫中加鎖的語法，需要確保資料的正確性。

2. 它認為 Table 裡面的 data 非常不安全，無時無刻都在變動，當一個 SQL command 獲得悲觀鎖後，其他的 SQL command 無法對這個 data 進行修改，直到悲觀鎖被釋放後才能執行。

3. 資料表中用 Synchronized 實現的鎖均為悲觀鎖 (ex：行鎖，表鎖，讀鎖，寫鎖)。

4. 優點 : 使用資料庫 `Transaction` 機制強迫執行順序，保證資料正確。

5. 缺點 : 由於加上鎖的機制，會導致其他功能需等待，造成系統吞吐量下降。

6. 更新的步驟為

    1. 對要做更新的資料加上 `Update Locks (U)` 悲觀鎖

        ```sql
        -- 開啟 Transaction 手動提交，不然會自動提交
        begin;

        -- 加上悲觀鎖
        SELECT num FROM `MyDB`.`items` WHERE id = 1 for update;
        ```
    
    2. 更新加了悲觀鎖的資料

        ```sql
        -- 數量減1
        UPDATE `MyDB`.`items` SET num = num -1 WHERE id = 1;

        -- 提交
        commit;
        ```
    
    3. 提交後，其他更新的動作才能使用





