## 最左匹配原理
* 在複合索引中，從最左邊的索引欄位開始匹配。

* 例如 : 索引為 (a, b, c) 欄位，則如果要命中索引，必須先使用 a 欄位的查詢條件，在使用 b，以此類推，否則無法命中索引。

    ```sql
    SELECT * FROM users WHERE a = 1 AND b = 2 AND c = 3;
    ```
* 需要命中索引，有以下幾種組合

    1. a
    2. ab
    3. ac
    4. abc

<br/>

<br/>

## Index 無法生效的8種寫法

* 觀念: 只要對索引欄位做手腳，索引就不會生效。

1. 使用 `NOT`, `!=`, `NOT IN`, `NOT LIKE`

2. 使用函數語句包裝被索引的欄位

    ```sql
    SELECT * FROM users WHERE DATE(created_at) = '2023-01-01';
    ```

3. 資料類型錯誤，若使用錯誤的類型，sql 判斷會做類別轉換，導致索引失效。

4. 使用模糊搜尋並且使用 '%' 開頭，有部分會從字元的最左匹配。

    ```sql
    SELECT * FROM users WHERE name like '%name%';
    ```

5. 使用 NULL，索引通常預設是不支援 NULL，但有些SQL可以將 NULL 納入索引中。

6. 錯誤的使用 OR，如果 OR 條件中，含有沒有被加入索引的欄位，則索引不會生效

    ```sql
    -- indexed_col為索引，unindexed_col非索引
    SELECT * FROM users WHERE indexed_col > 5 OR unindexed_col < 10;
    ```

7. 針對索引欄位做運算，同上，只要對欄位做手腳，索引不會生效。

    ```sql
    SELECT * FROM users WHERE height - 10 > 150;
    ```

8. 複合式索引使用錯誤，若複合索引依照此順序 `INDEX user_index(first_name, last_name, email)` 建立，則在搜尋時，需依照此三個欄位的順序，若使用以下，就會失效

    ```sql
    -- 跳過 last_name，直接接上 email，導致索引失效
    SELECT * FROM users WHERE first_name = 'aaa' AND email = 'aaa@aaa.com'
    ```

    * 所以合法的索引組合有三(才會生效)：

        1. first_name + last_name + email
        2. first_name + last_name
        3. first_name

<br/>

<br/>

## References

> https://medium.com/johnliu-%E7%9A%84%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E6%80%9D%E7%B6%AD/database-%E5%85%AB%E5%80%8B-index-%E7%B4%A2%E5%BC%95-%E7%84%A1%E6%B3%95%E7%94%9F%E6%95%88%E7%9A%84-sql-%E5%AF%AB%E6%B3%95-cdc7d2e72f51